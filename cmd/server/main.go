package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"sync"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	todov1 "todo/gen/todo/v1"        // generated by protoc-gen-go
	"todo/gen/todo/v1/todov1connect" // generated by protoc-gen-connect-go
	"todo/models"

	connectcors "connectrpc.com/cors"
	_ "github.com/go-sql-driver/mysql" // 空インポート
	"github.com/rs/cors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"

	"github.com/joho/godotenv"
)

type TodoServer struct {
	db     *sql.DB
	todos  sync.Map //スレッドセーフなMapらしい syncにいろいろある
	nextId int
}

func (s *TodoServer) CreateTask(
	ctx context.Context,
	req *connect.Request[todov1.CreateTaskRequest],
) (*connect.Response[todov1.CreateTaskResponse], error) {
	todo := &models.Todo{
		TodoLabel:  req.Msg.Name,
		TodoStatus: null.IntFrom(int(req.Msg.Status)),
	}

	todo.Insert(ctx, s.db, boil.Infer())

	log.Println("CreateTodo")

	log.Println("Request headers: ", req.Header())

	res := connect.NewResponse(&todov1.CreateTaskResponse{
		Id:     uint64(todo.ID),
		Name:   todo.TodoLabel,
		Status: todov1.Status(todo.TodoStatus.Int),
	})

	//一覧をログに表示
	LogTodoList(s)

	res.Header().Set("CreateTask-Version", "v1")
	return res, nil
}

func (s *TodoServer) UpdateTaskStatus(
	ctx context.Context,
	req *connect.Request[todov1.UpdateTaskStatusRequest],
) (*connect.Response[todov1.UpdateTaskStatusResponse], error) {
	updateId := req.Msg.Id
	log.Println("Request headers: ", req.Header())
	// FIND TODO ID
	todo, err := models.Todos(models.TodoWhere.ID.EQ(uint(req.Msg.Id))).One(ctx, s.db)
	if err != nil {
		err := fmt.Errorf("todo not found: %d", updateId)
		fmt.Printf("Todo not found: %d\n", updateId)
		return nil, err
	}

	// CHANGE TODO STATUS 1->2, 2->1
	if todo.TodoStatus.Int == 1 {
		todo.TodoStatus.Int = 2
	} else {
		todo.TodoStatus.Int = 1
	}

	// UPDATE TODO
	_, err = todo.Update(ctx, s.db, boil.Infer())

	if err != nil {
		return nil, err
	}

	res := connect.NewResponse(&todov1.UpdateTaskStatusResponse{
		Id:     uint64(todo.ID),
		Status: todov1.Status(todo.TodoStatus.Int),
	})

	//Todo一覧をログに表示
	LogTodoList(s)

	res.Header().Set("UpdateTaskStatus-Version", "v1")
	return res, nil
}

func isEmpty(m *sync.Map) bool {
	isEmpty := true
	m.Range(func(key, value interface{}) bool {
		isEmpty = false
		return false
	})
	return isEmpty
}

func (s *TodoServer) DeleteTask(
	ctx context.Context,
	req *connect.Request[todov1.DeleteTaskRequest],
) (*connect.Response[todov1.DeleteTaskResponse], error) {
	delId := req.Msg.Id

	_, err := models.Todos(models.TodoWhere.ID.EQ(uint(req.Msg.Id))).DeleteAll(ctx, s.db)
	if err != nil {
		fmt.Printf("Todo not found: %d\n", delId)
		return nil, err
	}

	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&todov1.DeleteTaskResponse{
		Id: delId,
	})
	LogTodoList(s)
	res.Header().Set("DeleteTask-Version", "v1")
	return res, nil
}

func LogTodoList(s *TodoServer) {
	log.Println("TODO一覧")
	var items []*todov1.TodoItem

	//GET ALL Todos
	todos, err := models.Todos().All(context.Background(), s.db)

	if err != nil {
		log.Fatal(err)
	}

	//Display Printf TodoList
	for _, todo := range todos {
		items = append(items, &todov1.TodoItem{
			Id:     uint64(todo.ID),
			Name:   todo.TodoLabel,
			Status: todov1.Status(todo.TodoStatus.Int),
		})
	}
	sort.Slice(items, func(i, j int) bool {
		return items[i].Id < items[j].Id
	})
	for _, item := range items {
		log.Printf("ID: %d, Name: %s, Status: %d\n", item.Id, item.Name, item.Status)
	}
}

func (s *TodoServer) GetAllTasks(
	ctx context.Context,
	req *connect.Request[todov1.GetAllTasksRequest],
) (*connect.Response[todov1.GetAllTasksResponse], error) {
	var items []*todov1.TodoItem
	s.todos.Range(func(key, value interface{}) bool {
		if item, ok := value.(*todov1.TodoItem); ok {
			items = append(items, item)
		}
		return true
	})

	//GET ALL Todos
	todos, err := models.Todos().All(ctx, s.db)

	if err != nil {
		return nil, err
	}

	log.Println("Request headers: ", req.Header())

	//make todo Items
	for _, todo := range todos {
		items = append(items, &todov1.TodoItem{
			Id:     uint64(todo.ID),
			Name:   todo.TodoLabel,
			Status: todov1.Status(todo.TodoStatus.Int),
		})
	}

	res := connect.NewResponse(&todov1.GetAllTasksResponse{
		Items: items,
	})

	res.Header().Set("GetAllTasks-Version", "v1")
	return res, nil
}

func main() {
	// DB接続
	err := godotenv.Load()

	if err != nil {
		log.Fatal("Error loading .env file")
	}

	user := os.Getenv("MYSQL_USER")
	pass := os.Getenv("MYSQL_PASSWORD")
	host := os.Getenv("MYSQL_HOST")
	port := os.Getenv("MYSQL_PORT")
	dbname := os.Getenv("MYSQL_DBNAME")
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true", user, pass, host, port, dbname)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	todoServer := &TodoServer{
		db: db,
	}
	mux := http.NewServeMux()
	path, handler := todov1connect.NewTodoServiceHandler(todoServer)

	log.Println("path: ", path, "handler: ", handler)
	mux.Handle(path, handler)

	//CORS対応
	corsHandler := withCORS(mux)

	http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(corsHandler, &http2.Server{}),
	)
}

func withCORS(h http.Handler) http.Handler {
	var (
		allowedMethods = connectcors.AllowedMethods()
		allowedHeaders = connectcors.AllowedHeaders()
		exposedHeaders = connectcors.ExposedHeaders()
	)
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{"http://127.0.0.1:5173"},
		AllowedMethods:   allowedMethods,
		AllowedHeaders:   allowedHeaders,
		ExposedHeaders:   exposedHeaders,
		AllowCredentials: true,
		MaxAge:           7200,
	})
	return c.Handler(h)
}
